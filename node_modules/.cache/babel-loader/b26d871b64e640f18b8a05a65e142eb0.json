{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  var isWordDelimiter = function (c) {\n    return c === \" \" || c.charCodeAt(0) === 10;\n  }; // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n\n\n  var start = 0; // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n\n  var end = text.length; // iterate to the left\n\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  } // iterate to the right\n\n\n  for (var i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nexports.getSurroundingWord = getSurroundingWord;\n\nfunction selectWord(_a) {\n  var text = _a.text,\n      selection = _a.selection;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;","map":{"version":3,"sources":["/Users/jubi/fullStack/pro1/profile/node_modules/react-mde/lib/js/util/MarkdownUtil.js"],"names":["Object","defineProperty","exports","value","getSurroundingWord","text","position","Error","isWordDelimiter","c","charCodeAt","start","end","length","i","selectWord","_a","selection","getBreaksNeededForEmptyLineBefore","startPosition","neededBreaks","isInFirstLine","getBreaksNeededForEmptyLineAfter","isInLastLine"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getSurroundingWord(text, position) {\n    if (!text)\n        throw Error(\"Argument 'text' should be truthy\");\n    var isWordDelimiter = function (c) { return c === \" \" || c.charCodeAt(0) === 10; };\n    // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n    var start = 0;\n    // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n    var end = text.length;\n    // iterate to the left\n    for (var i = position; i - 1 > -1; i--) {\n        if (isWordDelimiter(text[i - 1])) {\n            start = i;\n            break;\n        }\n    }\n    // iterate to the right\n    for (var i = position; i < text.length; i++) {\n        if (isWordDelimiter(text[i])) {\n            end = i;\n            break;\n        }\n    }\n    return { start: start, end: end };\n}\nexports.getSurroundingWord = getSurroundingWord;\nfunction selectWord(_a) {\n    var text = _a.text, selection = _a.selection;\n    if (text && text.length && selection.start === selection.end) {\n        // the user is pointing to a word\n        return getSurroundingWord(text, selection.start);\n    }\n    return selection;\n}\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === 0)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInFirstLine = true;\n    for (var i = startPosition - 1; i >= 0 && (neededBreaks >= 0); i--) {\n        switch (text.charCodeAt(i)) {\n            case 32: // blank space\n                continue;\n            case 10: // line break\n                neededBreaks--;\n                isInFirstLine = false;\n                break;\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInFirstLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === text.length - 1)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInLastLine = true;\n    for (var i = startPosition; i < text.length && (neededBreaks >= 0); i++) {\n        switch (text.charCodeAt(i)) {\n            case 32:\n                continue;\n            case 10: {\n                neededBreaks--;\n                isInLastLine = false;\n                break;\n            }\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInLastLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;\n"]},"metadata":{},"sourceType":"script"}